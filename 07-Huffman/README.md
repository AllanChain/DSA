# Huffman 树上机报告

## 问题理解

根据词频，自下而上构建 Huffman 树，获得最优编码，然后根据生成的二叉树进行编码和翻译。

## 设计和实现

由于总字符数未知，使用链表 `LinkCharNode` 来存储所有字符的权重 `w`，并预留 `code` 字段以便存储二进制编码。然后根据权重大致按照书本的算法生成 Huffman 树 `htree`，根据 `htree` 在字符链表中生成编码“字典”。这里的 01 编码也使用链表的数据结构，这样可以实现任意长度的编码，二是可以在添加过程中实现倒序。

在逐比特存储读取时，使用 `static` 变量实现暂存功能，等到满一字节再存储，以及先读取一字节然后逐比特返回。

## 编程环境

|Key      |Value       |Version|
|:--------|:-----------|:------|
|System   |WSL Ubuntu  | 19.10 |
|Language |C           |       |
|Compiler |g++         | 9.2.1 |
|Debugger |gdb         | 8.3   |
|Formatter|clang-format| 9.0.0 |
|Editor   |VS Code     | 1.44.0|

## 上机收获

### 不要轻易对形如 `a.b` 赋值，除非你知道你在干什么

为了方便，令了一个变量 `node = htree->hArr[i]`，并对它的成员赋值。结果就是 `htree` 内的纹丝不动。因为 C 是直接硬拷贝了这个结构体。

解决方法就是使用取地址的指针。

### EOF 的确不是一个字符

文件读取只有先尝试读取，才会知道有没有数据、是不是到文件尾。所以 `feof` 是逻辑上晚于 `fgetc` 返回 EOF 的。EOF 只是表示文件读不下去了，至于是出错还是到文件尾了不知道，这时候才需要使用 `feof` 和 `ferror` 来判断是具体什么情况。

以及不要用 `!feof(f)` 做 `while` 循环条件。（澄清：这里需要一个字符作为结尾，并偷个懒，所以这么写）如果是文件读取遇到错误，那么循环永远不会退出。

所以往文件里写 EOF 也是不对的。

### Huffman 树的数据结构设计

书本的设计还是很巧妙的，通过顺序存储 2m+1 个结点，不仅不必动态申请，也使获得 Huffman 编码的操作大大简化，不必从根开始遍历 Huffman 树。美中不足的是引用的方式比较丑陋复杂，不过仍在可接受范围内。

## 改进空间

可以对字符链表进行排序，配合二分查找，加快对目标的查询。
