# 迷宫问题的广度优先搜索求解

## 问题理解

迷宫问题广度优先，即多条路齐头并进，如遇死路或走过即放弃这条支路。直到到达出口或者所有支路都达到死路为止。

## 设计与实现

使用队列的链接表示存储当前所有的支路信息。

开始从 `maze.txt` 读取地图信息填入整型数组中，提取出口、入口，并标记通道、障碍。每次循环遍历上下左右，只有标记为通道的才可抵达，每到达一个位置，就将其前驱的位置写在迷宫数组的该位置上，该位置也自动标记为非通道。

由于数组为整型数组，故也要将坐标 `(row, col)` 转化为一个整数即总的编号存储。

最后图形化打印路线。由于直接一行行扫描打印并不方便，故先构造字符数组，然后再从出口回溯，依次添加 `-` 或 `|`。

## 编程环境

|Key      |Value       |Version|
|:--------|:-----------|:------|
|System   |WSL Ubuntu  | 19.10 |
|Language |C           |       |
|Compiler |g++         | 9.2.1 |
|Debugger |gdb         | 8.3   |
|Formatter|clang-format| 9.0.0 |
|Editor   |VS Code     | 1.43.1|

## 上机问题与解决

### 没有 `rear`?

书上在给空队列插入时，只对 `front` 进行了处理，但是没有处理 `rear`。。成功被坑。

### 转换出来位置不对？手贱打错

`row * ROLS + col` 多和谐呀，怎么可能错呢？

### 一直无解？

忘记记录出口前驱了 \_(：3 」∠ )\_

### 怎么循环东西南北？

在 Python 里可以这样：

```python
for i, j in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
    pass
```

但是 c 里除了重复 4 遍，只能：

```c
for (int i = -1; i <= 1; i++) {
    for (int j = -1; j <= 1; j++) {
        if (i + j == 1 || i + j == -1) {
            // do sth
        }
    }
}
```

## 有待改进

几个地图处理函数耦合度太高，尤其对于出口和入口的处理，是留在地图上还是擦去，要不要返回或者作为参数，没有处理好。

对地图字符和迷宫数组的转换部分过于冗杂，一堆 `case`，要是有字典就好了。
