## 线性表

### 复习题 4

存储位置 指针指示

### 复习题 6

#### 顺序存储

- 优点
    - 存储密度大，空间利用率高
    - 可快速访问任意一个元素，达到随机存储的效果。
- 缺点
    - 插入和删除需要移动后面的元素，时间复杂度高
    - 难以扩展，需要按最大可能长度分配

#### 链式存储

- 优点
    - 空间动态申请和释放，更灵活
    - 删除和插入只需更改指针，效率高
- 缺点
    - 存储密度小
    - 不能随机访问，查找复杂

### 复习题 7

B

### 算法题 3

```
i 从 1 到 (n 整除 2):
    交换 e[i] 和 e[n-i]
```

### 算法题 12

```
prev = 头结点
p0 从头结点（不含）开始遍历链表：
    p1 从头结点到 p0（不含）遍历：
        如果 p1 和 p0 的数据相同：
            prev 指向 p0 后一个
            释放 p0 空间
            跳出循环
    prev = p0
```

### 算法题 16

```

p = [list1, list2]
比较两链表头结点的数据大小，取较小的（设为 i）为新的头结点 head，p[i] 后移
prev = head
当 p[0] != list1 且 p[1] != list2：
    如果 p[i] 值 > p[1-i] 值：
        t = p[1-i]
        将 t 插入 prev 和 p[i] 之间
        prev = t
        p[1-i] 后移
    prev = p[i]
    否则 p[i] 后移
如果 p[1-i] != list1：
    将 p[1-i] 头尾分别和 prev head 链接
```

## 栈与队列

### 复习题 1

**栈** 插入和删除限制在表的同一端的线性表

**栈顶** 栈中允许插入和删除的一端

**栈底** 栈中不允许插入和删除的一端

**队列** 只允许在表的一端进行插入操作，在另一端进行删除操作的线性表

**队列的头** 允许进行删除操作的一端

**队列的尾** 允许进行插入操作的一端

**先进先出** 每次出列的是当前队列中最先被加入的元素

**先进后出** 最先插入的元素被压在栈的底部，只有后插入的元素全部删除后才能被删除

**递归函数** 自己调用自己的函数

**深度优先** 在途径的每个分支点选一个分支前进，保留其它可能分支的信息，遇到死路时回溯

**宽度优先** 按与初始点的距离，在所有可能路径上一步步齐头并进，在每个点探索所有下一步可能到达的点

### 算法题 2

```
当 n > 0：
    将 n 模 2 压入栈
    n = n 整除 2
从栈中依次取出打印
```

### 算法题 7

```
s1 栈顶变量 top1 赋值 -1
s2 栈顶变量 top2 赋值 n

s1.pop():
    if top1 == -1:
        error
    return a[top1--]
s1.push(x):
    if top2 - top1 == 1:
        overflow
    a[top1++] = x
```

### 算法题 9

```
full():
    return quelen == m
put(x):
    if full(): error
    rear = (rear - 1 + m) % m
    sequ[rear] = x
get():
    if quelen == 0: error
    quelen--
    return sequ[(rear + quelen) % m]
```
